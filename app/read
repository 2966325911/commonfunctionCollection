Binder大致的通信过程：
1.一个进程使用BINDERSETCONTEXT_MGR命令通过Binder驱动将自己注册成为ServiceManager
2.Server通过驱动向ServiceManger中注册Binder（Server中的Binder实体）,可以表明对外提供服务，
驱动为这个Binder创建位于内核中的实体点以及ServiceManager对实体的应用，将名字以及新建的引用
打包传给ServiceManager，ServiceManger将其填入查找表
3.Client通过名字，在Binder驱动的帮助下从ServiceManger中获取到对Binder实体的引用，通过对
这个引用就能实现和Server进程通信


Android绘制框架中，CPU的作用主要是负责了视图的测量，计算，布局记录，把内容计算成Polygons多变形或者Texture纹理，
GPU则主要负责把 Polygons或者Textture进行Rasterization栅格化，在屏幕上成像，开启硬件加速后，则GPU分担CPU的
计算任务，CPU会更加专注逻辑任务的处理减轻CPU的负担，是系统运行效率提高

硬件加速的原理：通过底层的软件代码，将CPU不擅长的图形计算转换为GPU专用指令，由GPU完成
硬件加速渲染，就是通过GPU来进行渲染，
硬件加速的过程中包括两个阶段：
（1）构建阶段　遍历所有视图，将需要绘制的操作缓存下来，交给单独的Render 线程使用GPU进行硬件加速绘制（这一阶段在主线程CPU构建）
（2）绘制阶段 调用OpenGl(即使用GPU)对构建好的视图进行绘制渲染，绘制的内容保存在Graphic Buffer并交给
SurfaceFlinger 显示

ThreadedRenderer的主要作用就是在主线程中(CPU)构建视图，并将构建好的视图通知到RenderThread让其使用OpenGl绘制渲染
只有支持并开启硬件加速的View才会关联有RenderNode，同时GPU不是支持所有的2D 所以GPU不支持的绘制命令只能通过软件方式来绘制渲染

布局中去掉重复或者不必要的background能够加快CPU的构建速度，同时能够减轻GPU渲染负担

FileLock进程文件锁，可以控制不同程序对同一文件的并发访问
如果是共享锁 则可以对同一文件进行读操作，不可以进行写操作，写操作会抛出异常
如果是独占所，则同一时间只能有一个线程对其进行读写操作，直到文件锁被释放掉，才可以被其他线程访问，对于操作并发是安全的

头条屏幕适配方案
density = 屏幕宽度 / 设计图宽度  一个view的显示为50dp 系统最终会转换为px  则 50*density
缩放系数为50 * density/屏幕宽度 与view的宽度 50/设计图宽度 一致  view的实际宽度 为 50/设计图宽度 * 50
全局修改density   dp = px / (dpi/160)  density = dpi/160  dpi(像素密度)为160的设备上1dp = 1px

ldpi   density = 0.75 分辨率 240 * 320   关系  dp = px/0.75
mdpi   density = 1    分辨率 320 * 480   dp = px/1
hdpi   density = 1.5  分辨率 480 * 800   dp = px/1.5
xhdpi  density = 2.0  分辨率 720 * 1280  dp = px/2.0
xxhdpi density = 3.0  分辨率 1080 * 1920 dp = px/3.0

Java中的IO流主要是面向流，阻塞式IO NIO主要是面向缓冲，非
阻塞式，支持选择器操作

通过Cache-control 和ETag的配合来实现Http的缓存机制 http2.0二进制分帧
三次握手中的第三次握手是为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误

并发锁的特点就是并发读读不互斥、并发读写互斥、并发写写互斥
线程进入读锁的前提条件是没有其他线程占用写请求或者有写请求但调用线程和持有锁的线程是同一个线程，
线程进入写锁的前提条件是没有其他线程占用读锁，也没有其他线程占用写锁

ReentrantReadWriteLock 不支持锁升级，只支持锁降级，锁降级是对统一线程从写锁变成读锁，锁升级就是
对同意线程从读锁变成写锁，读锁是多线程共享锁，写锁是多线程互斥锁，写锁的并发限制比读锁搞。

View 绘制 流程最终调用的是ViewRootImpl中的performTraversals 方法来完成绘制的，performTraversals
中依次调用performMeasure() performLayout() performDraw()

在view post中才可以拿到view的宽高信息，在onCreate或者其他生命周期中也不一定拿到，调用view的post方法可拿到是
因为在view绘制performTraversals中将其利用post方法加入到消息队列中，到执行改方法时候，view的测量流程已经完成，


Object的wait和notify/notify是与对象监视器配合完成线程间的等待/通知机制，而Condition与Lock配合完成等待通知机制，
前者是java底层级别的，后者是语言级别的，具有更高的可控制性和扩展性。
java 线程Lock锁使用Condition实现线程的等待（await）与通知（signal）
Conditioin与重入锁时是通过Lock中的lock.newCondition方法产生一个与当前重入锁绑定的Condition实例
即：  Lock lock = new ReentrantLock(); Condition condition = lock.newCondition();
public interface Condition{
    //使当前线程加入await（）等待队列中，并释放锁，当其他线程调用signal()会重新请求锁，
    //与Object.await()类似
    void await() throws InterruptedException;
    //调用该方法的前提是，当前线程已经成功获得与该条件对象绑定的重入锁，否则调用该方法时会抛出IllegalMonitorStateException。
    //调用该方法后，结束等待的唯一方法是其它线程调用该条件对象的signal()或signalALL()方法。等待过程中如果当前线程被中断，该方法仍然会继续等待，同时保留该线程的中断状态。
    void awaitUninterruptibly();

    //若指定时间内有其它线程中断该线程，则抛出InterruptedException并清除当前线程的打断状态；若指定时间内未收到通知，则返回0或负数。
     long awaitNanos(long nanosTimeout) throws InterruptedException;

     //与await()基本一致，唯一不同点在于，指定时间之内没有收到signal()或signalALL()信号或者线程中断时该方法会返回false;其它情况返回true。
     boolean await(long time, TimeUnit unit) throws InterruptedException;

     //唤醒一个在 await()等待队列中的线程。与Object.notify()相似
      void signal();

      //唤醒 await()等待队列中所有的线程。与object.notifyAll()相似
      void signalAll();

}


Canvas 有layer层级的概念，缺省情况只有一个layer，可以用saveLayerXXX，Restore等方法创建层级，按照栈方式管理，创建一个新的Layer到
栈中，用saveLayer，saveLayerAlpha，从栈中推出一个Layer，可以使用restore，restoreToCount，当Layer入栈时，后续DrawXXX操作都发生
到这个Layer上，而Layer退栈时，就会把本层绘制的图像绘制到上层或是Canvas中
通过saveLayer方法新建一层级，再通过restoreToCount方法将新层还原回画布，这样就不会对原有的层进行干扰。

Glide的图片加载网络请求最终是在HttpUrlFetcher类中发生的，用的是HttpUrlConnection获取数据流并通过DataFetcher接口中的DataCallback
的onDataReady方法返回出去，最终在DecodeJob中的decodeFromRetrievedData()中待资源加载完成后回调，
在decodeFromRetrievedData（）中调用decodeFromData()方法进行缩放，转换等操作，返回Resource对象,
当resource成功返回即(resource！= null)调用notifyEncodeAndRelease通过DecodeJob加载后对数据后做转换，
缓存等操作，回到EngineJob中，通过onResourceReady（）中的MAIN_THREAD_HANDLER.obtainMessage(MSG_COMPLETE, this).sendToTarget();
将其切换到主线程中，调用handleResultOnMainThread(),通过EngineJobListenerde onEngineJobComplete()方法添加到缓存,
最终调用DrawableImageViewTarget的ssetResource()方法将图片设置到ImageView上


LruCache算法核心 = LRU算法 + LinkedHashMap数据结构
LRU Least Recently Used最近最少使用算法 原理 ：当缓存满时，优先淘汰近期最少使用的缓存对象
采用LRU 算法的缓存类型 内存缓存 磁盘缓存

LinkedHashMap  数据结构 = 数组 + 单链表 +双向链表　　双向链表实现了 存储顺序 = 访问顺序 / 插入顺序

java 的反射对象类Class 、Constructor、Field,Method,Package实现了AnnotatedElement 的接口
Annotation 主要分类有三种：1 内置的Annotation  eg:@Override 2 作用于Annotation的Annotation
eg : @Retention @Documented @ Target   @Inherited表示该Annotation可以影响到被标注的类的子类
3 自定义Annotation java1.5以后可以自定义Annotation